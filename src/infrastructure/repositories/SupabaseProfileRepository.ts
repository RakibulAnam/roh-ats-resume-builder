import { supabase } from '../supabase/client';
import { IProfileRepository } from '../../domain/repositories/IProfileRepository';
import { PersonalInfo, WorkExperience, Education, Project, UserType, Extracurricular, Award, Certification, Affiliation, Publication } from '../../domain/entities/Resume';

export class SupabaseProfileRepository implements IProfileRepository {

    // --- User Type & Profile Completeness ---
    async getUserType(userId: string): Promise<UserType | null> {
        const { data, error } = await supabase
            .from('profiles')
            .select('user_type')
            .eq('id', userId)
            .single();

        if (error) return null;
        return data?.user_type as UserType | null;
    }

    async saveUserType(userId: string, userType: UserType): Promise<void> {
        const { error } = await supabase
            .from('profiles')
            .update({ user_type: userType, updated_at: new Date().toISOString() })
            .eq('id', userId);

        if (error) throw error;
    }

    async isProfileComplete(userId: string): Promise<boolean> {
        try {
            // Check explicit flag
            const { data, error } = await supabase
                .from('profiles')
                .select('onboarding_complete')
                .eq('id', userId)
                .single();

            if (error) return false;
            return data?.onboarding_complete === true;
        } catch {
            return false;
        }
    }

    async markProfileComplete(userId: string): Promise<void> {
        const { error } = await supabase
            .from('profiles')
            .update({ onboarding_complete: true, updated_at: new Date().toISOString() })
            .eq('id', userId);

        if (error) throw error;
    }

    // --- Profile ---
    async getProfile(userId: string): Promise<PersonalInfo | null> {
        const { data, error } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', userId)
            .single();

        if (error) throw error;
        if (!data) return null;

        return {
            fullName: data.full_name || '',
            email: data.email || '',
            phone: data.phone || '',
            location: data.location || '',
            linkedin: data.linkedin || '',
            github: data.github || '',
            website: data.website || '',
        };
    }

    async saveProfile(userId: string, data: PersonalInfo): Promise<void> {
        const { error } = await supabase
            .from('profiles')
            .upsert({
                id: userId,
                full_name: data.fullName,
                email: data.email,
                phone: data.phone,
                location: data.location,
                linkedin: data.linkedin,
                github: data.github,
                website: data.website,
                updated_at: new Date().toISOString(),
            });

        if (error) throw error;
    }

    // --- Experience ---
    async getExperiences(userId: string): Promise<WorkExperience[]> {
        const { data, error } = await supabase
            .from('experiences')
            .select('*')
            .eq('user_id', userId)
            .order('start_date', { ascending: false });

        if (error) throw error;

        return (data || []).map((item: any) => ({
            id: item.id,
            company: item.company,
            role: item.role,
            startDate: item.start_date,
            endDate: item.end_date,
            isCurrent: item.is_current,
            rawDescription: item.description,
            refinedBullets: [], // Stored in applications, not master profile usually, or we can add it later
        }));
    }

    async saveExperience(userId: string, experience: WorkExperience): Promise<void> {
        // If id is temporary (generated by frontend), we should omit it to let DB generate UUID
        // OR ensure frontend generates valid UUIDs. Assuming frontend generates valid UUIDs or we handle upsert.
        // For simplicity, let's treat 'new' items clearly.

        // Check if ID is a valid UUID, if not (e.g. '123'), generate one or let DB do it? 
        // Best practice: let DB handle ID if new.

        const payload: any = {
            user_id: userId,
            company: experience.company,
            role: experience.role,
            start_date: experience.startDate,
            end_date: experience.endDate,
            is_current: experience.isCurrent,
            description: experience.rawDescription,
        };

        if (experience.id && experience.id.length > 20) { // Simple check for UUID-like length
            payload.id = experience.id;
        }

        const { error } = await supabase
            .from('experiences')
            .upsert(payload);

        if (error) throw error;
    }

    async deleteExperience(id: string): Promise<void> {
        const { error } = await supabase.from('experiences').delete().eq('id', id);
        if (error) throw error;
    }

    // --- Education ---
    async getEducations(userId: string): Promise<Education[]> {
        const { data, error } = await supabase
            .from('educations')
            .select('*')
            .eq('user_id', userId)
            .order('start_date', { ascending: false });

        if (error) throw error;

        return (data || []).map((item: any) => ({
            id: item.id,
            school: item.school,
            degree: item.degree,
            field: item.field,
            startDate: item.start_date,
            endDate: item.end_date,
            gpa: item.gpa,
        }));
    }

    async saveEducation(userId: string, education: Education): Promise<void> {
        const payload: any = {
            user_id: userId,
            school: education.school,
            degree: education.degree,
            field: education.field,
            start_date: education.startDate,
            end_date: education.endDate,
            gpa: education.gpa,
        };

        if (education.id && education.id.length > 20) {
            payload.id = education.id;
        }

        const { error } = await supabase.from('educations').upsert(payload);
        if (error) throw error;
    }

    async deleteEducation(id: string): Promise<void> {
        const { error } = await supabase.from('educations').delete().eq('id', id);
        if (error) throw error;
    }

    // --- Projects ---
    async getProjects(userId: string): Promise<Project[]> {
        const { data, error } = await supabase
            .from('projects')
            .select('*')
            .eq('user_id', userId)
            .order('created_at', { ascending: false });

        if (error) throw error;

        return (data || []).map((item: any) => ({
            id: item.id,
            name: item.name,
            rawDescription: item.description, // Correct mapping
            technologies: item.technologies,
            link: item.link,
            refinedBullets: [],
        }));
    }

    async saveProject(userId: string, project: Project): Promise<void> {
        const payload: any = {
            user_id: userId,
            name: project.name,
            description: project.rawDescription,
            technologies: project.technologies,
            link: project.link,
        };

        if (project.id && project.id.length > 20) {
            payload.id = project.id;
        }

        const { error } = await supabase.from('projects').upsert(payload);
        if (error) throw error;
    }

    async deleteProject(id: string): Promise<void> {
        const { error } = await supabase.from('projects').delete().eq('id', id);
        if (error) throw error;
    }

    // --- Skills ---
    async getSkills(userId: string): Promise<string[]> {
        const { data, error } = await supabase
            .from('skills')
            .select('name')
            .eq('user_id', userId);

        if (error) throw error;
        return (data || []).map((item: any) => item.name);
    }

    async saveSkills(userId: string, skills: string[]): Promise<void> {
        // Delete existing skills and replace (simplest strategy for list of strings)
        // Or intelligent upsert. For now, delete all for user and re-insert is safest to sync list.

        // Warning: This could be heavy if invoked frequently.
        // Better: Only insert new ones? But then how to handle deletions?
        // Transactional replace:

        const { error: deleteError } = await supabase
            .from('skills')
            .delete()
            .eq('user_id', userId);

        if (deleteError) throw deleteError;

        if (skills.length === 0) return;

        const rows = skills.map(name => ({
            user_id: userId,
            name: name,
        }));

        const { error: insertError } = await supabase
            .from('skills')
            .insert(rows);

        if (insertError) throw insertError;
    }

    // --- Extracurriculars ---
    async getExtracurriculars(userId: string): Promise<Extracurricular[]> {
        const { data, error } = await supabase
            .from('extracurriculars')
            .select('*')
            .eq('user_id', userId)
            .order('start_date', { ascending: false });

        if (error) throw error;
        return (data || []).map((item: any) => ({
            id: item.id,
            title: item.title,
            organization: item.organization,
            startDate: item.start_date,
            endDate: item.end_date,
            description: item.description,
            refinedBullets: [],
        }));
    }

    async saveExtracurricular(userId: string, item: Extracurricular): Promise<void> {
        const payload: any = {
            user_id: userId,
            title: item.title,
            organization: item.organization,
            start_date: item.startDate,
            end_date: item.endDate,
            description: item.description,
        };
        if (item.id && item.id.length > 20) payload.id = item.id;
        const { error } = await supabase.from('extracurriculars').upsert(payload);
        if (error) throw error;
    }

    async deleteExtracurricular(id: string): Promise<void> {
        const { error } = await supabase.from('extracurriculars').delete().eq('id', id);
        if (error) throw error;
    }

    // --- Awards ---
    async getAwards(userId: string): Promise<Award[]> {
        const { data, error } = await supabase
            .from('awards')
            .select('*')
            .eq('user_id', userId)
            .order('date', { ascending: false });

        if (error) throw error;
        return (data || []).map((item: any) => ({
            id: item.id,
            title: item.title,
            issuer: item.issuer,
            date: item.date,
            description: item.description,
        }));
    }

    async saveAward(userId: string, item: Award): Promise<void> {
        const payload: any = {
            user_id: userId,
            title: item.title,
            issuer: item.issuer,
            date: item.date,
            description: item.description,
        };
        if (item.id && item.id.length > 20) payload.id = item.id;
        const { error } = await supabase.from('awards').upsert(payload);
        if (error) throw error;
    }

    async deleteAward(id: string): Promise<void> {
        const { error } = await supabase.from('awards').delete().eq('id', id);
        if (error) throw error;
    }

    // --- Certifications ---
    async getCertifications(userId: string): Promise<Certification[]> {
        const { data, error } = await supabase
            .from('certifications')
            .select('*')
            .eq('user_id', userId)
            .order('date', { ascending: false });

        if (error) throw error;
        return (data || []).map((item: any) => ({
            id: item.id,
            name: item.name,
            issuer: item.issuer,
            date: item.date,
            link: item.link,
        }));
    }

    async saveCertification(userId: string, item: Certification): Promise<void> {
        const payload: any = {
            user_id: userId,
            name: item.name,
            issuer: item.issuer,
            date: item.date,
            link: item.link,
        };
        if (item.id && item.id.length > 20) payload.id = item.id;
        const { error } = await supabase.from('certifications').upsert(payload);
        if (error) throw error;
    }

    async deleteCertification(id: string): Promise<void> {
        const { error } = await supabase.from('certifications').delete().eq('id', id);
        if (error) throw error;
    }

    // --- Affiliations ---
    async getAffiliations(userId: string): Promise<Affiliation[]> {
        const { data, error } = await supabase
            .from('affiliations')
            .select('*')
            .eq('user_id', userId)
            .order('start_date', { ascending: false });

        if (error) throw error;
        return (data || []).map((item: any) => ({
            id: item.id,
            organization: item.organization,
            role: item.role,
            startDate: item.start_date,
            endDate: item.end_date,
        }));
    }

    async saveAffiliation(userId: string, item: Affiliation): Promise<void> {
        const payload: any = {
            user_id: userId,
            organization: item.organization,
            role: item.role,
            start_date: item.startDate,
            end_date: item.endDate,
        };
        if (item.id && item.id.length > 20) payload.id = item.id;
        const { error } = await supabase.from('affiliations').upsert(payload);
        if (error) throw error;
    }

    async deleteAffiliation(id: string): Promise<void> {
        const { error } = await supabase.from('affiliations').delete().eq('id', id);
        if (error) throw error;
    }

    // --- Publications ---
    async getPublications(userId: string): Promise<Publication[]> {
        const { data, error } = await supabase
            .from('publications')
            .select('*')
            .eq('user_id', userId)
            .order('date', { ascending: false });

        if (error) throw error;
        return (data || []).map((item: any) => ({
            id: item.id,
            title: item.title,
            publisher: item.publisher,
            date: item.date,
            link: item.link,
        }));
    }

    async savePublication(userId: string, item: Publication): Promise<void> {
        const payload: any = {
            user_id: userId,
            title: item.title,
            publisher: item.publisher,
            date: item.date,
            link: item.link,
        };
        if (item.id && item.id.length > 20) payload.id = item.id;
        const { error } = await supabase.from('publications').upsert(payload);
        if (error) throw error;
    }

    async deletePublication(id: string): Promise<void> {
        const { error } = await supabase.from('publications').delete().eq('id', id);
        if (error) throw error;
    }
}
